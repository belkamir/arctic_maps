{"version":3,"sources":["components/GeojsonLayer.jsx","components/GeojsonBasemap.jsx","components/Water.jsx","components/Roads.jsx","components/Russia.jsx","components/MapGeojson.jsx","App.js","serviceWorker.js","index.js"],"names":["GeojsonLayer","props","myStyle","color","weight","fillColor","opacity","fillOpacity","state","data","console","log","info","this","FeatureGroup","map","f","GeoJSON","key","properties","id","style","Popup","NAME","url","fetchData","fetch","then","r","json","setState","features","error","React","Component","GeojsonBase","Opacity","name","GeojsonWater","GeojsonRoads","GeojsonRussia","L","Icon","Default","imagePath","crs","Proj","CRS","resolutions","MapComponent","lat","lng","zoom","layer","onBMChange","bm","onGeojsonToggle","e","geojsonvisible","currentTarget","checked","center","z","Map","minZoom","maxBounds","LayersControl","position","Overlay","ScaleControl","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"sYAIqBA,G,wDACnB,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IASRC,QAAU,WACR,MAAO,CACLC,MAAO,UACPC,OAAQ,EACRC,UAAW,UACXC,QAAS,EACXC,YAAa,KAbb,EAAKC,MAAQ,CACXC,KAAM,IAGRC,QAAQC,IAAI,cAPK,E,0CAoBnB,WAAU,IAAD,OAIP,OAHAD,QAAQC,IAAI,UAEZD,QAAQE,KAAKC,KAAKL,MAAMC,MAEtB,kBAACK,EAAA,EAAD,KACGD,KAAKL,MAAMC,KAAKM,KAAI,SAAAC,GACnB,OAAO,kBAACC,EAAA,EAAD,CAASC,IAAKF,EAAEG,WAAWC,GAAIX,KAAMO,EAAGK,MAAO,EAAKnB,SACxD,kBAACoB,EAAA,EAAD,KAAQN,EAAEG,WAAWI,a,+BAOhC,WACMV,KAAKZ,MAAMuB,KACbX,KAAKY,UAAUZ,KAAKZ,MAAMuB,KAE5Bd,QAAQC,IAAI,e,kCAGd,WACED,QAAQC,IAAI,kB,uBAId,SAAUa,GAAM,IAAD,OACCE,MAAMF,GAGjBG,MAAK,SAAAC,GAAC,OAAIA,EAAEC,UACZF,MAAK,SAAAlB,GACJ,EAAKqB,SAAS,CACZrB,KAAMA,EAAKsB,cAEZ,SAACC,GACFtB,QAAQsB,MAAMA,U,GA1DoBC,IAAMC,YCA3BC,E,kDACnB,WAAYlC,GAAQ,IAAD,8BACjB,cAAMA,IASRC,QAAU,WACR,MAAO,CACLC,MAAO,UACPC,OAAQ,GACRgC,QAAS,EACT/B,UAAW,UACXE,YAAa,IAbf,EAAKC,MAAQ,CACXC,KAAM,IAGRC,QAAQC,IAAI,cAPK,E,0CAqBnB,WAAU,IAAD,OAIP,OAHAD,QAAQC,IAAI,UAEZD,QAAQE,KAAKC,KAAKL,MAAMC,MAEtB,kBAACK,EAAA,EAAD,KACGD,KAAKL,MAAMC,KAAKM,KAAI,SAAAC,GACnB,OAAO,kBAACC,EAAA,EAAD,CAASC,IAAKF,EAAEG,WAAWC,GAAIX,KAAMO,EAAGK,MAAO,EAAKnB,SACxD,kBAACoB,EAAA,EAAD,KAAQN,EAAEG,WAAWkB,a,+BAOhC,WACMxB,KAAKZ,MAAMuB,KACbX,KAAKY,UAAUZ,KAAKZ,MAAMuB,KAE5Bd,QAAQC,IAAI,e,kCAGd,WACED,QAAQC,IAAI,kB,uBAId,SAAUa,GAAM,IAAD,OACCE,MAAMF,GAGjBG,MAAK,SAAAC,GAAC,OAAIA,EAAEC,UACZF,MAAK,SAAAlB,GACJ,EAAKqB,SAAS,CACZrB,KAAMA,EAAKsB,cAEZ,SAACC,GACFtB,QAAQsB,MAAMA,U,GA3DmBC,IAAMC,WCA1BI,E,kDACnB,WAAYrC,GAAQ,IAAD,8BACjB,cAAMA,IASRC,QAAU,WACR,MAAO,CACLC,MAAO,UACPC,OAAQ,EACRE,QAAS,EACTD,UAAW,UACbE,YAAa,IAbb,EAAKC,MAAQ,CACXC,KAAM,IAGRC,QAAQC,IAAI,cAPK,E,0CAoBnB,WAAU,IAAD,OAIP,OAHAD,QAAQC,IAAI,UAEZD,QAAQE,KAAKC,KAAKL,MAAMC,MAEtB,kBAACK,EAAA,EAAD,KACGD,KAAKL,MAAMC,KAAKM,KAAI,SAAAC,GACnB,OAAO,kBAACC,EAAA,EAAD,CAASC,IAAKF,EAAEG,WAAWC,GAAIX,KAAMO,EAAGK,MAAO,EAAKnB,SACxD,kBAACoB,EAAA,EAAD,KAAQN,EAAEG,WAAWI,a,+BAOhC,WACMV,KAAKZ,MAAMuB,KACbX,KAAKY,UAAUZ,KAAKZ,MAAMuB,KAE5Bd,QAAQC,IAAI,e,kCAGd,WACED,QAAQC,IAAI,kB,uBAId,SAAUa,GAAM,IAAD,OACCE,MAAMF,GAGjBG,MAAK,SAAAC,GAAC,OAAIA,EAAEC,UACZF,MAAK,SAAAlB,GACJ,EAAKqB,SAAS,CACZrB,KAAMA,EAAKsB,cAEZ,SAACC,GACFtB,QAAQsB,MAAMA,U,GA1DoBC,IAAMC,WCA3BK,E,kDACnB,WAAYtC,GAAQ,IAAD,8BACjB,cAAMA,IASRC,QAAU,WACR,MAAO,CACLC,MAAO,UACPC,OAAQ,EACRE,QAAS,IAXX,EAAKE,MAAQ,CACXC,KAAM,IAGRC,QAAQC,IAAI,cAPK,E,0CAmBnB,WAAU,IAAD,OAIP,OAHAD,QAAQC,IAAI,UAEZD,QAAQE,KAAKC,KAAKL,MAAMC,MAEtB,kBAACK,EAAA,EAAD,KACGD,KAAKL,MAAMC,KAAKM,KAAI,SAAAC,GACnB,OAAO,kBAACC,EAAA,EAAD,CAASC,IAAKF,EAAEG,WAAWC,GAAIX,KAAMO,EAAGK,MAAO,EAAKnB,SACxD,kBAACoB,EAAA,EAAD,KAAQN,EAAEG,WAAWI,a,+BAOhC,WACMV,KAAKZ,MAAMuB,KACbX,KAAKY,UAAUZ,KAAKZ,MAAMuB,KAE5Bd,QAAQC,IAAI,e,kCAGd,WACED,QAAQC,IAAI,kB,uBAId,SAAUa,GAAM,IAAD,OACCE,MAAMF,GAGjBG,MAAK,SAAAC,GAAC,OAAIA,EAAEC,UACZF,MAAK,SAAAlB,GACJ,EAAKqB,SAAS,CACZrB,KAAMA,EAAKsB,cAEZ,SAACC,GACFtB,QAAQsB,MAAMA,U,GAzDoBC,IAAMC,WCA3BM,E,kDACnB,WAAYvC,GAAQ,IAAD,8BACjB,cAAMA,IASRC,QAAU,WACR,MAAO,CACLC,MAAO,UACPC,OAAQ,EACRE,QAAS,EACTD,UAAW,UACXE,YAAa,IAbf,EAAKC,MAAQ,CACXC,KAAM,IAGRC,QAAQC,IAAI,cAPK,E,0CAoBnB,WAAU,IAAD,OAIP,OAHAD,QAAQC,IAAI,UAEZD,QAAQE,KAAKC,KAAKL,MAAMC,MAEtB,kBAACK,EAAA,EAAD,KACGD,KAAKL,MAAMC,KAAKM,KAAI,SAAAC,GACnB,OAAO,kBAACC,EAAA,EAAD,CAASC,IAAKF,EAAEG,WAAWC,GAAIX,KAAMO,EAAGK,MAAO,EAAKnB,SACxD,kBAACoB,EAAA,EAAD,KAAQN,EAAEG,WAAWI,a,+BAOhC,WACMV,KAAKZ,MAAMuB,KACbX,KAAKY,UAAUZ,KAAKZ,MAAMuB,KAE5Bd,QAAQC,IAAI,e,kCAGd,WACED,QAAQC,IAAI,kB,uBAId,SAAUa,GAAM,IAAD,OACCE,MAAMF,GAGjBG,MAAK,SAAAC,GAAC,OAAIA,EAAEC,UACZF,MAAK,SAAAlB,GACJ,EAAKqB,SAAS,CACZrB,KAAMA,EAAKsB,cAEZ,SAACC,GACFtB,QAAQsB,MAAMA,U,GA1DqBC,IAAMC,W,wBCYjDO,IAAEC,KAAKC,QAAQC,UAAY,+CAE3B,IAAMC,EAAM,IAAIJ,IAAEK,KAAKC,IAAI,YAAY,8EACtC,CAACC,YAAa,CAAE,MAAO,MAAO,KAAM,KAAM,KAAM,KAAM,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,MAiE/EC,E,4MA3DbzC,MAAQ,CACN0C,IAAK,GACLC,IAAK,GACLC,KAAM,EACNC,MAAO,U,EAGTC,WAAa,SAACC,GAEZ,EAAKzB,SAAS,CACZuB,MAAOE,K,EAIXC,gBAAkB,SAACC,GAEjB,EAAK3B,SAAS,CACZ4B,eAAgBD,EAAEE,cAAcC,W,4CAIpC,WACE,IAAIC,EAAS,CAAChD,KAAKL,MAAM0C,IAAKrC,KAAKL,MAAM2C,KACrCW,EAAIjD,KAAKL,MAAM4C,KAGnB,OACE,kBAACW,EAAA,EAAD,CAAKX,KAAMU,EAAGD,OAAQA,EAASG,QAAS,EAAIC,UAAW,CAAC,CAAC,GAAI,IAAK,CAAC,IAAK,MAAQpB,IAAOA,GAExF,kBAAC,EAAD,CAAarB,IAAI,4BAEjB,kBAAC,EAAD,CAAeA,IAAK,uBACpB,kBAAC,EAAD,CAAcA,IAAI,iBAClB,kBAAC,EAAD,CAAcA,IAAI,kBAClB,kBAAC,EAAD,CAAcA,IAAK,qBAGnB,kBAAC0C,EAAA,EAAD,CAAeC,SAAS,YAExB,kBAACD,EAAA,EAAcE,QAAf,CAAuB/B,KAAK,kCAC3B,kBAAC,EAAD,CAAcb,IAAI,0BAGlB,kBAAC0C,EAAA,EAAcE,QAAf,CAAuB/B,KAAK,kCAC5B,kBAAC,EAAD,CAAcb,IAAI,2BAGlB,kBAAC0C,EAAA,EAAcE,QAAf,CAAuB/B,KAAK,8CAC5B,kBAAC,EAAD,CAAcb,IAAI,0BAIlB,kBAAC6C,EAAA,EAAD,CAAcF,SAAS,qB,GArDFlC,IAAMC,W,MCdlBoC,MANf,WACE,OACE,kBAAC,EAAD,OCMgBC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD6H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMvD,MAAK,SAAAwD,GACjCA,EAAaC,kB","file":"static/js/main.a1dfb092.chunk.js","sourcesContent":["import React from 'react';\nimport { GeoJSON, FeatureGroup, Popup } from 'react-leaflet';\nimport \"../css/GeojsonLayer.css\"\n\nexport default class GeojsonLayer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      data: []\n    };\n\n    console.log('contructor');\n  }\n\n  myStyle = () => {\n    return {\n      color: \"#917047\",\n      weight: 2,\n      fillColor: \"#d0a066\",\n      opacity: 1,\n    fillOpacity: 0.6\n    }\n  }\n\n  render() {\n    console.log('render');\n\n    console.info(this.state.data);\n    return (\n      <FeatureGroup>\n        {this.state.data.map(f => {\n          return <GeoJSON key={f.properties.id} data={f} style={this.myStyle}>\n             <Popup>{f.properties.NAME}</Popup>\n          </GeoJSON>\n        })}\n      </FeatureGroup>\n    );\n  }\n\n  componentDidMount() {\n    if (this.props.url) {\n      this.fetchData(this.props.url);\n    }\n    console.log('did mount');\n  }\n\n  componentWillUnmount() {\n    console.log('will unmount');\n\n  }\n\n  fetchData(url) {\n    let request = fetch(url);\n\n    request\n      .then(r => r.json())\n      .then(data => {\n        this.setState({\n          data: data.features\n        });\n      }, (error) => {\n        console.error(error);\n      });\n  }\n}","import React from 'react';\nimport { GeoJSON, FeatureGroup, Popup} from 'react-leaflet';\nimport \"../css/GeojsonLayer.css\"\n\nexport default class GeojsonBase extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      data: []\n    };\n\n    console.log('contructor');\n  }\n\n  myStyle = () => {\n    return {\n      color: \"#b3b2b1\",\n      weight: 0.8,\n      Opacity: 1,\n      fillColor: \"#CED2D6\",\n      fillOpacity: 1\n      //dashArray: '5 5'\n    }\n  }\n\n  render() {\n    console.log('render');\n\n    console.info(this.state.data);\n    return (\n      <FeatureGroup>\n        {this.state.data.map(f => {\n          return <GeoJSON key={f.properties.id} data={f} style={this.myStyle}>\n             <Popup>{f.properties.name}</Popup>\n          </GeoJSON>\n        })}\n      </FeatureGroup>\n    );\n  }\n\n  componentDidMount() {\n    if (this.props.url) {\n      this.fetchData(this.props.url);\n    }\n    console.log('did mount');\n  }\n\n  componentWillUnmount() {\n    console.log('will unmount');\n\n  }\n\n  fetchData(url) {\n    let request = fetch(url);\n\n    request\n      .then(r => r.json())\n      .then(data => {\n        this.setState({\n          data: data.features\n        });\n      }, (error) => {\n        console.error(error);\n      });\n  }\n}","import React from 'react';\nimport { GeoJSON, FeatureGroup, Popup } from 'react-leaflet';\nimport \"../css/GeojsonLayer.css\"\n\nexport default class GeojsonWater extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      data: []\n    };\n\n    console.log('contructor');\n  }\n\n  myStyle = () => {\n    return {\n      color: \"#9fbfc6\",\n      weight: 1,\n      opacity: 1, \n      fillColor: \"#9fbfc6\", \n    fillOpacity: 1,\n    }\n  }\n\n  render() {\n    console.log('render');\n\n    console.info(this.state.data);\n    return (\n      <FeatureGroup>\n        {this.state.data.map(f => {\n          return <GeoJSON key={f.properties.id} data={f} style={this.myStyle}>\n             <Popup>{f.properties.NAME}</Popup>\n          </GeoJSON>\n        })}\n      </FeatureGroup>\n    );\n  }\n\n  componentDidMount() {\n    if (this.props.url) {\n      this.fetchData(this.props.url);\n    }\n    console.log('did mount');\n  }\n\n  componentWillUnmount() {\n    console.log('will unmount');\n\n  }\n\n  fetchData(url) {\n    let request = fetch(url);\n\n    request\n      .then(r => r.json())\n      .then(data => {\n        this.setState({\n          data: data.features\n        });\n      }, (error) => {\n        console.error(error);\n      });\n  }\n}","import React from 'react';\nimport { GeoJSON, FeatureGroup, Popup } from 'react-leaflet';\nimport \"../css/GeojsonLayer.css\"\n\nexport default class GeojsonRoads extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      data: []\n    };\n\n    console.log('contructor');\n  }\n\n  myStyle = () => {\n    return {\n      color: \"#f0f0f0\",\n      weight: 1,\n      opacity: 1 \n   \n    }\n  }\n\n  render() {\n    console.log('render');\n\n    console.info(this.state.data);\n    return (\n      <FeatureGroup>\n        {this.state.data.map(f => {\n          return <GeoJSON key={f.properties.id} data={f} style={this.myStyle}>\n             <Popup>{f.properties.NAME}</Popup>\n          </GeoJSON>\n        })}\n      </FeatureGroup>\n    );\n  }\n\n  componentDidMount() {\n    if (this.props.url) {\n      this.fetchData(this.props.url);\n    }\n    console.log('did mount');\n  }\n\n  componentWillUnmount() {\n    console.log('will unmount');\n\n  }\n\n  fetchData(url) {\n    let request = fetch(url);\n\n    request\n      .then(r => r.json())\n      .then(data => {\n        this.setState({\n          data: data.features\n        });\n      }, (error) => {\n        console.error(error);\n      });\n  }\n}","import React from 'react';\nimport { GeoJSON, FeatureGroup, Popup } from 'react-leaflet';\nimport \"../css/GeojsonLayer.css\"\n\nexport default class GeojsonRussia extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      data: []\n    };\n\n    console.log('contructor');\n  }\n\n  myStyle = () => {\n    return {\n      color: \"#E3DFDA\",\n      weight: 1,\n      opacity: 1, \n      fillColor: \"#d5d2cd\", \n      fillOpacity: 1\n    }\n  }\n\n  render() {\n    console.log('render');\n\n    console.info(this.state.data);\n    return (\n      <FeatureGroup>\n        {this.state.data.map(f => {\n          return <GeoJSON key={f.properties.id} data={f} style={this.myStyle}>\n             <Popup>{f.properties.NAME}</Popup>\n          </GeoJSON>\n        })}\n      </FeatureGroup>\n    );\n  }\n\n  componentDidMount() {\n    if (this.props.url) {\n      this.fetchData(this.props.url);\n    }\n    console.log('did mount');\n  }\n\n  componentWillUnmount() {\n    console.log('will unmount');\n\n  }\n\n  fetchData(url) {\n    let request = fetch(url);\n\n    request\n      .then(r => r.json())\n      .then(data => {\n        this.setState({\n          data: data.features\n        });\n      }, (error) => {\n        console.error(error);\n      });\n  }\n}","import React from \"react\";\nimport L from 'leaflet';\nimport { Map, LayersControl, ScaleControl} from \"react-leaflet\";\nimport GeojsonLayer from './GeojsonLayer';\nimport GeojsonBase from './GeojsonBasemap';\nimport GeojsonWater from './Water';\nimport GeojsonRoads from './Roads';\nimport GeojsonRussia from './Russia';\nimport '../css/Map.css';\nimport \"polarmap\";\nimport \"proj4leaflet\";\nimport \"proj4\";\n\n\n\n// указываем путь к файлам marker\nL.Icon.Default.imagePath = \"https://unpkg.com/leaflet@1.5.0/dist/images/\";\n\nconst crs = new L.Proj.CRS(\"EPSG:3576\",\"+proj=laea +lat_0=90 +lon_0=90 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs\",\n {resolutions: [ 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5]\n  //origin: [ -180, -90 ]         \n}\n);\n\nclass MapComponent extends React.Component {\n  state = {\n    lat: 70,\n    lng: 80,\n    zoom: 2,\n    layer: 'cities'\n  };\n\n  onBMChange = (bm) => {\n    // console.log(this);\n    this.setState({\n      layer: bm\n    });\n  }\n\n  onGeojsonToggle = (e) => {\n    \n    this.setState({\n      geojsonvisible: e.currentTarget.checked\n    });\n  }\n\n  render() {\n    var center = [this.state.lat, this.state.lng];\n    var z = this.state.zoom;\n\n\n    return (\n      <Map zoom={z} center={center}  minZoom={2}  maxBounds={[[20, 50], [870, 2000]]} crs = {crs}>\n      \n     <GeojsonBase url=\"countries_arctic_2.json\" />\n\n     <GeojsonRussia url= \"russia_new.geojson\" />\n     <GeojsonWater url=\"lakes_s.json\" />\n     <GeojsonWater url=\"rivers_s.json\" />\n     <GeojsonRoads url= \"rus_roads_s.json\" />\n\n\n     <LayersControl position=\"topright\">\n\n     <LayersControl.Overlay name=\"Линии\">\n      <GeojsonLayer url=\"arctic_lines.geojson\" />\n      </LayersControl.Overlay>\n\n      <LayersControl.Overlay name=\"Точки\">\n      <GeojsonLayer url=\"arctic_points.geojson\"/>\n      </LayersControl.Overlay>\n\n      <LayersControl.Overlay name=\"Плигоны\">\n      <GeojsonLayer url=\"arctic_poly.geojson\" />\n      </LayersControl.Overlay>\n      </LayersControl>\n\n      <ScaleControl position=\"bottomright\" />\n\n      </Map>\n    );\n  }\n};\n\nexport default MapComponent;","import React from 'react';\nimport MapComponent from \"./components/MapGeojson.jsx\";\nimport './App.css';\n\nfunction App() {\n  return (\n    <MapComponent />\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}